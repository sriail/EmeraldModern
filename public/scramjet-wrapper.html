<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Scramjet wrapper</title>
  <style>html,body,#contentFrame{height:100%;margin:0;padding:0;border:0}</style>
</head>
<body>
  <!-- The wrapper loads the proxied page in an inner iframe so we can inject interception code in a same-origin context -->
  <iframe id="contentFrame" sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-presentation allow-top-navigation-by-user-activation allow-pointer-lock" src="" frameborder="0" width="100%" height="100%"></iframe>

  <script>
    (function () {
      // Read proxied URL from query parameter 'url'
      const params = new URLSearchParams(location.search);
      const proxiedUrl = params.get('url');
      const inner = document.getElementById('contentFrame');

      if (!proxiedUrl) {
        inner.srcdoc = '<p style="padding:20px">No url specified</p>';
        return;
      }

      // Install a message listener to accept navigation requests from inner iframe
      // and forward them to the parent (the actual app). We will post messages from inner to this wrapper,
      // then this wrapper will forward to window.parent so the app can change the top-level tab iframe src.
      window.addEventListener('message', (ev) => {
        try {
          const d = ev.data;
          if (!d || typeof d !== 'object') return;
          // forward specific navigation messages up to the parent
          if (d && d.type === 'scramjet-nav-request' && d.url) {
            // forward to parent app
            window.parent.postMessage({ type: 'scramjet-nav-request', url: d.url }, '*');
          }
        } catch (e) {
          console.warn('wrapper message error', e);
        }
      }, false);

      // Inject a small script into the inner iframe via srcdoc that overrides event handlers.
      // We can't write into cross-origin proxied page directly; instead we'll load the proxied page into the iframe
      // and use a content script approach: set inner.src to the proxied URL that is served by the service worker proxy,
      // *but* we can also listen for messages from the inner frame. To enable internal interception we attempt to inject
      // into same-origin documents; for cross-origin, the inner page itself will not be editable, so we provide a fallback:
      // the inner iframe will attempt to install override and post navigation requests to this wrapper by posting to parent.
      inner.src = proxiedUrl;

      // As a precaution: if inner content is same-origin we can try to inject directly when it loads.
      inner.addEventListener('load', () => {
        try {
          const cw = inner.contentWindow;
          if (!cw) return;

          // If same-origin, install the interception directly (best-effort).
          // This also helps the proxied page handle target="_blank" anchors and window.open.
          try {
            // Only install if not already present
            if (!cw.__scramjetNavInstalled) {
              cw.__scramjetNavInstalled = true;

              // Override window.open
              cw.window.open = function (url, target, features) {
                try {
                  // send navigation request up to wrapper
                  cw.parent.postMessage({ type: 'scramjet-nav-request', url: String(url) }, '*');
                } catch (e) { /* ignore */ }
                // return a minimal window-like object to silence callers
                return { closed: false, close: () => {}, focus: () => {}, blur: () => {}, postMessage: () => {} };
              };

              // Intercept clicks on anchors
              cw.document.addEventListener('click', function (e) {
                let a = e.target;
                while (a && a.nodeName !== 'A') a = a.parentElement;
                if (!a) return;
                const href = a.getAttribute('href');
                const target = a.getAttribute('target');
                if (!href) return;
                // Only intercept navigations that are not internal hash or JS void
                if (href.startsWith('javascript:') || href.startsWith('#')) return;
                // Prevent default and forward navigation to wrapper-parent
                e.preventDefault();
                cw.parent.postMessage({ type: 'scramjet-nav-request', url: new URL(href, cw.location.href).toString() }, '*');
              }, true);

              // Intercept form submissions
              cw.document.addEventListener('submit', function (e) {
                const form = e.target;
                try {
                  const formAction = form.action || cw.location.href;
                  e.preventDefault();
                  cw.parent.postMessage({ type: 'scramjet-nav-request', url: new URL(formAction, cw.location.href).toString() }, '*');
                } catch (err) { /* ignore */ }
              }, true);
            }
          } catch (injErr) {
            // Accessing inner.document may fail if cross-origin - that's expected.
            // In that case, the proxied page won't have our interception directly injected,
            // but we can still catch navigation attempts if the proxied page cooperates (posts messages).
            console.warn('Could not inject into proxied page (likely cross-origin):', injErr);
          }
        } catch (e) {
          console.warn('inner load handler', e);
        }
      }, false);
    })();
  </script>
</body>
</html>
